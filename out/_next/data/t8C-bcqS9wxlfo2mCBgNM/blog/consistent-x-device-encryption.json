{"pageProps":{"post":{"path":"blog/consistent-x-device-encryption","title":"Getting consistent Encryption in Node / PHP / Browser and openSSL","subtitle":null,"published":true,"datePublished":1603967203286,"tags":["encryption","decryption","openssl","nodejs","php"],"description":null,"canonicalUrl":"https://dev.lwlx.xyz/","author":"lwlx","authorPhoto":"/profile.jpg","authorTwitter":"InfoSecx0","bannerPhoto":"/crypto.jpg","thumbnailPhoto":"/crypto_thumb.jpg","content":"\nI recently was tasked to find a solution for encrypting data in different places and to be able to decrypt them all in a browser during runtime.\n\nSurprisingly, it was much harder than expected since there was so little documentation around this online. What was available were a few code only examples, so I was forced to do R&D and just try all implementations and compare the in- & outputs\n\nGiven the lack of a decent out-of-the-box solution, I worry that many developers are settling for easy to use, insecure, solutions which place limits on the security and flexibility of your project. Security should be easy to use and accessible.\n\n> Clone the repo here to get started with this setup: <a href=\"https://gist.github.com/Lawlez/88e04e3541cc0608c953a118b86bfc1a\">https://gist.github.com/Lawlez/88e04e3541cc0608c953a118b86bfc1a</a>\n\nOkay, so lets assume we use following input data to test each implementation:\n- **`key`** = '5035ae3567f2e69320b083d59a7364cf8d4b14e77d7b798051241ce546b327d9'  ` //must be 256 bits`\n- **`iv`** = '1d6ef201e0e7a9019ddf8414034325e2' ` //must be 128 bits`\n- **`inputData`** = `{\"TestData\":\"w17h Spé^cIäl chàær§¢tèrs\", \"OK\":\"://seems/fine?x=lol\"}`\n\nLet's quickly run through each implementation:\n\n### Using Node JS Crypto module\n\nNode Provides a nice `crypto`  implementation. It's documentation is rather sparse, but this is what I ended up with by using:\n- `crypto.randomBytes()`\n- `crypto.createCipheriv()`\n- `crypto.createDecipheriv()`\n\n```javascript\nconst crypto = require('crypto')\n\n/**********************************************************************\n*\n*        DECRYPTION MODULE FOR USE INSIDE NODE.JS                     *\n*\n***********************************************************************/\n\nconst encryption = (data = 'TestString {} Héllöüä') => {\n\n    const secretPhrase = crypto.randomBytes(16).toString('hex')\n    const salt = crypto.randomBytes(128 / 8).toString('hex')\n    //here we generate the key and give it back as a string, we use 100k iterations\n    //as suggested in best practices\n    //We can use the key multiple times to encrypt multiple things(-30GB), we just cant use\n    //the same initialization vector twice\n    //the key for aes-256 needs to be 256 bits which equals 32 bytes or 32 characters\n    const configKey = crypto.pbkdf2Sync(secretPhrase, salt, 100000, 32, 'sha256').toString('hex').substr(0, 32)\n    //create unique IV for each encryption, the key can be reused. IV needs to always be 16 bytes\n    const IV = crypto.randomBytes(16)\n\n    //create ciphers for each encryption using the shared key and the unuique IV\n    const projectConfigCipher = crypto.createCipheriv('aes-256-cbc', configKey, IV.toString('hex').substr(0,16)\n\n    //encripting the storage location using the prepared cipher\n    const encrypted = Buffer.concat([configStorageCipher.update(\n        'STORAGE', 'utf8'\n    ), configStorageCipher.final()]).toString('hex')\n\n\treturn encrypted\n\n}\n```\n#### Testing the implementation\n\nthe first thing we notice is that we need to trim the key to 32bytes and the IV to 16 bytes. this is likely because of the conversion from hex to string after creation of the key.\n\n- **`key`** = '5035ae3567f2e69320b083d59a7364cf'  ` //is now 32 bytes string`\n- **`iv`** = '1d6ef201e0e7a901' ` //is now 16 bytes string`\n\nthis will probably lead to an issue later on, since other implementations actually want the longer strings. maybe we can find a work around by base64 encoding instead of stringifying the key and iv.\n\na quick test reveals, yes we actually can:\n```\nconst IV = crypto.randomBytes(16)\nconsole.log(IV) // <Buffer c1 1e 98 84 54 eb 85 f6 b3 d0 51 87 d2 62 80 a7>\n    console.log(IV.toString('base64')) // wR6YhFTrhfaz0FGH0mKApw==\n    console.log(Buffer.from(IV.toString('base64'), 'base64')) //<Buffer c1 1e 98 84 54 eb 85 f6 b3 d0 51 87 d2 62 80 a7>\n```\n\nThe output we recieve is of type buffer, but when we convert it to string using `toString('hex')` we can read the data:\n\n- **`OUTPUT`** = '<Buffer f2 fb 62 b1 7e e9 da 0c 8c bd 56 f2 45 a9 87 60 b4 e2 a6 d0 c5 de f1 50 bc 6d 86 00 f8 5d b4 79>' ` //is 32 bytes`\n- **`OUTPUT_Stringified`** = 'f2fb62b17ee9da0c8cbd56f245a98760b4e2a6d0c5def150bc6d8600f85db479' ` //is now 64 bytes string`\n- **`OUTPUT_Base64`** = '8vtisX7p2gyMvVbyRamHYLTiptDF3vFQvG2GAPhdtHk=' ` //is now 44 bytes string`\n\nso using the codes below we can switch between theese three outputs as we like\n\n```javascript\n//output Buffer\nencrypted = Buffer.concat([encrypted, Cipher.final()])\n\n//output String\nencrypted = Buffer.concat([encrypted, Cipher.final()]).toString('hex')\n\n\n//output Base64\nencrypted = Buffer.concat([encrypted, Cipher.final()]).toString('base64')\n\n//revert conversion to base64\nBuffer.from(encrypted.toString('base64') , 'base64')\n```\n\nFrom what we have learned here i guess the best option is to use the base64 output method, since we can easily convert it to a buffer\n\n### Using browserify-aes's node crypto like implementation inside the Browser\n\nInside the browser, we cannot use Nodes.js built-in modules. Using `browserify-aes` we can use a node-like crypto implementation, which uses the same syntax as the node implementation. In my use case, I only need to decipher in the browser, this means I don’t have to worry about a true random key generation or ciphering.\n\n```js\nimport crypto from 'browserify-aes'\n\n/**********************************************************************\n*\n*        DECRYPTION MODULE FOR USE IN BROWSER DURING RUNTIME          *\n*\n***********************************************************************/\nconst decrypt = hash => {\n    const hash = hash.data\n    //get IV from input, make sure its no longer than 16 bytes\n    const IV = hash.IV\n\n    //ein neuer cipher wird vorbereitet, mittels aes256, unserem 256 bit KEY und dem config IV\n    const decipher = crypto.createDecipheriv(\n        'aes256',\n        process.env.APP_CONFIG_KEY.substr(0, 32),\n       IV,\n    )\n\n    //der hash wird nun decrypted mittels dem zuvor erstellten cipher\n    const decrypted = Buffer.concat([decipher.update(\n         Buffer.from(hash, 'hex'),\n     ), decipher.final()]).toString()\n\n   return JSON.parse(decrypted)\n}\n```\n\n### ENCRYPTION & DECRYPTION MODULE FOR PHP7+ USING OPENSSL\n\nIn PHP 7 we make use of the `openssl_encrypt` implementation to encrypt an utf8 string and finally encode it with `base64_encode`.\nFor decryption we also make use of the official openssl implementation `openssl_decrypt`, before decrypting we need to decode using `base64_decode`.\n\n```php\n/**********************************************************************\n*\n*        ENCRYPTION & DECRYPTION MODULE FOR PHP7+ USING OPENSSL       *\n*\n***********************************************************************/\n\nclass AESEncryption {\n\n\t//key length should be 256 bits for aes 256 this means we use a string with 32 bytes\n\tpublic static $key = \"5f08e0ec585393a8e2ca8f0a1a0ae752\";\n\n\t //iv length should be always be 128 bit / 16 bytes\n\tpublic static $iv = \"05d387e7f773035a\";\n\n\t // The AES uses a block size of sixteen octets (128 bits)\n\tpublic static $Method = 'AES-256-CBC';\n\n\t/**\n\t  * use the AES to encrypt plaintext data and return a base 64 string\n\t *\n\t * $key\n\t */\n\tpublic static function encrypt($cleartext,$key = ''){\n\n\t\t$key = empty($key) ? self::$key : $key;\n\n\t\t$encrypted = openssl_encrypt($cleartext, self::$Method, $key, OPENSSL_RAW_DATA, self::$iv);\n\n\t\treturn base64_encode($encrypted);\n\n\t}\n\n\t/**\n\t  * use the AES to decrypt a base 64 string into plaintext\n\t *\n\t * $key\n\t */\n\tpublic static function decrypt($encrypted,$key = ''){\n\n\t\t$key = empty($key) ? self::$key : $key;\n\n\t\t$encrypted = base64_decode($encrypted);\n\n\t\t$decrypted = openssl_decrypt($encrypted, self::$Method, $key, OPENSSL_RAW_DATA, self::$iv);\n\n\t\treturn trim($decrypted);\n\t}\n}\n```\n\n### Using openssl for use in CLI\n\nInside of a Command Line Interface we use `openssl` do en- or decrypt data.\n\nfor node/browserify to be able to decrypt it we need to add the `-nosalt` option, which disables salting the data.\n\n```bash\n#########################################################################################\n#                                                                                       #\n#               ENCRYPTION FOR CLI IN / MACOS / LINUX / WINDOWS                         #\n#                                                                                       #\n#########################################################################################\n\n#encrypt with key & IV but no salt\ncat config.json | openssl aes-256-cbc -iv $(cat iv)  -K $(cat key) -A -nosalt -base64\n\n#decrypt with key IV and base64\necho \"encryptedString\" | openssl aes-256-cbc -d -iv $(cat iv)  -K $(cat key) -base64 -A\n```\n#### testing the implementation\n\nI created a json file called `test.json` containing the inputData. so when we run the following command ...\n```bash\ncat test.json | openssl aes-256-cbc -iv \"1d6ef201e0e7a9019ddf8414034325e2\"  -K \"5035ae3567f2e69320b083d59a7364cf8d4b14e77d7b798051241ce546b327d9\" -A -nosalt\n```\nWe get no warnings and an output like this:\n- **`OUTPUT`** = g??.G?٪a?W????ԝFv?? 0P0+v?'???R=CR??a?\t?5!??N?\"?e?q?M{C\\??:u-?wH?? ` //weird looking binary data`\n\nas you can see this is not very usefull so we apply the base64 encoding after encryption\n```bash\ncat test.json | openssl aes-256-cbc -iv \"1d6ef201e0e7a9019ddf8414034325e2\"  -K \"5035ae3567f2e69320b083d59a7364cf8d4b14e77d7b798051241ce546b327d9\" -A -nosalt -base64\n```\n- **`OUTPUT_base64`** = Z8QIo6YuR7DZqmHHV4WqqorUnUZ2n88gMFADMCt2FKUn/ZeYUj1DEBNS2NthignUNR0hw+OOFU7qACKPZbxx8k0Pe0McXNDrOnUtl3dIwdg= ` //now this looks nice`\n\nnow we can also decrypt the just created data like so\n\n```bash\necho $encryptedData | openssl aes-256-cbc -d -iv \"1d6ef201e0e7a9019ddf8414034325e2\" -K \"5035ae3567f2e69320b083d59a7364cf8d4b14e77d7b798051241ce546b327d9\" -A -base64\n```\nThis yields us this outpu\n- **`OUTPUT`** = {\"TestData\":\"w17h Spé^cIäl chàær§¢tèrs\", \"OK\":\"://seems/fine?x=lol\"} ` //yes, thats out original input! :)`\n\n\n## final solution\n\n...\n"}},"__N_SSG":true}